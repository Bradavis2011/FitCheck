generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String?
  username  String?  @unique
  bio       String?
  passwordHash String?  @map("password_hash") // Optional: null for Clerk users
  profileImageUrl String? @map("profile_image_url")
  isPublic  Boolean  @default(false) @map("is_public")

  // Preferences
  stylePreferences Json? @default("{}") @map("style_preferences")
  bodyType         String? @map("body_type")
  colorSeason      String? @map("color_season")
  height           String? // "petite", "average", "tall"
  lifestyle        String[] @default([]) // ["Student", "Office worker", "Creative professional", etc.]
  fashionGoals     String[] @default([]) @map("fashion_goals") // ["Look professional", "Express creativity", etc.]
  fitPreference    String? @map("fit_preference") // "relaxed", "fitted", "balanced"
  budgetLevel      String? @map("budget_level") // "budget", "mid-range", "investment"

  // Subscription
  tier                  String   @default("free") // free, plus, pro
  subscriptionExpiresAt DateTime? @map("subscription_expires_at")
  revenuecatId          String?  @unique @map("revenuecat_id")
  subscriptionProductId String?  @map("subscription_product_id")
  subscriptionStore     String?  @map("subscription_store")

  // Usage tracking
  dailyChecksUsed   Int      @default(0) @map("daily_checks_used")
  dailyChecksResetAt DateTime @default(now()) @map("daily_checks_reset_at") @db.Date

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  outfitChecks OutfitCheck[]
  userStats    UserStats?
  communityFeedbackGiven CommunityFeedback[] @relation("UserFeedbackGiven")
  reports      Report[]
  blockedUsers BlockedUser[]  @relation("UserBlocks")
  blockedBy    BlockedUser[]  @relation("UserBlockedBy")
  followers        Follow[]            @relation("UserFollowers")
  following        Follow[]            @relation("UserFollowing")
  notifications    Notification[]      @relation("UserNotifications")
  pushTokens       PushToken[]         @relation("UserPushTokens")
  hostedSessions   LiveSession[]       @relation("UserLiveSessions")
  liveChatMessages LiveChatMessage[]   @relation("UserLiveChatMessages")
  liveSessionViews LiveSessionViewer[] @relation("UserLiveSessionViews")
  subscriptionEvents SubscriptionEvent[]

  @@map("users")
}

model OutfitCheck {
  id     String @id @default(uuid())
  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Image data
  imageUrl  String? @map("image_url")
  imageData String? @db.Text
  thumbnailUrl String? @map("thumbnail_url")
  thumbnailData String? @db.Text @map("thumbnail_data")
  imageType String @default("photo") @map("image_type") // photo, video

  // Context provided by user
  occasions        String[]
  setting          String?
  weather          String?
  vibe             String?
  specificConcerns String? @map("specific_concerns")

  // AI Feedback
  aiFeedback     Json?     @map("ai_feedback")
  aiScore        Float?    @map("ai_score")
  aiProcessedAt  DateTime? @map("ai_processed_at")
  promptVersion  String?   @map("prompt_version") // Tracks which prompt version produced this analysis

  // User rating of feedback
  feedbackHelpful Boolean? @map("feedback_helpful")
  feedbackRating  Int?     @map("feedback_rating") // 1-5

  // Community scores (cached)
  communityAvgScore   Float? @map("community_avg_score")
  communityScoreCount Int    @default(0) @map("community_score_count")

  // Metadata
  isFavorite Boolean @default(false) @map("is_favorite")
  isDeleted  Boolean @default(false) @map("is_deleted")
  isPublic   Boolean @default(false) @map("is_public")

  createdAt DateTime @default(now()) @map("created_at")

  followUps FollowUp[]
  communityFeedback CommunityFeedback[]
  styleDNA StyleDNA?

  @@map("outfit_checks")
}

model FollowUp {
  id            String      @id @default(uuid())
  outfitCheckId String      @map("outfit_check_id")
  outfitCheck   OutfitCheck @relation(fields: [outfitCheckId], references: [id], onDelete: Cascade)

  userQuestion String @map("user_question")
  aiResponse   String? @map("ai_response")

  createdAt DateTime @default(now()) @map("created_at")

  @@map("follow_ups")
}

model UserStats {
  userId String @id @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  totalFeedbackGiven Int @default(0) @map("total_feedback_given")
  totalHelpfulVotes  Int @default(0) @map("total_helpful_votes")
  currentStreak      Int @default(0) @map("current_streak")
  longestStreak      Int @default(0) @map("longest_streak")
  points             Int @default(0)
  level              Int @default(1)

  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("user_stats")
}

model CommunityFeedback {
  id        String      @id @default(uuid())
  outfitId  String      @map("outfit_id")
  outfit    OutfitCheck @relation(fields: [outfitId], references: [id], onDelete: Cascade)
  userId    String      @map("user_id")
  user      User        @relation("UserFeedbackGiven", fields: [userId], references: [id], onDelete: Cascade)
  score     Int
  comment   String
  createdAt DateTime    @default(now()) @map("created_at")

  @@unique([outfitId, userId])
  @@map("community_feedback")
}

model Report {
  id         String   @id @default(uuid())
  reporterId String   @map("reporter_id")
  reporter   User     @relation(fields: [reporterId], references: [id])
  targetType String   @map("target_type") // "outfit" or "user"
  targetId   String   @map("target_id")
  reason     String   // "inappropriate", "spam", "other"
  details    String?
  status     String   @default("pending") // "pending", "reviewed", "resolved"
  createdAt  DateTime @default(now()) @map("created_at")

  @@map("reports")
}

model BlockedUser {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  user      User     @relation("UserBlocks", fields: [userId], references: [id], onDelete: Cascade)
  blockedId String   @map("blocked_id")
  blocked   User     @relation("UserBlockedBy", fields: [blockedId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now()) @map("created_at")

  @@unique([userId, blockedId])
  @@map("blocked_users")
}

model Follow {
  id          String   @id @default(uuid())
  followerId  String   @map("follower_id")
  follower    User     @relation("UserFollowers", fields: [followerId], references: [id], onDelete: Cascade)
  followingId String   @map("following_id")
  following   User     @relation("UserFollowing", fields: [followingId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now()) @map("created_at")

  @@unique([followerId, followingId])
  @@map("follows")
}

model Notification {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  user      User     @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
  type      String   // "feedback", "follow", "milestone", "live"
  title     String
  body      String
  linkType  String?  @map("link_type") // "outfit", "user", "live_session"
  linkId    String?  @map("link_id")
  isRead    Boolean  @default(false) @map("is_read")
  createdAt DateTime @default(now()) @map("created_at")

  @@map("notifications")
  @@index([userId, createdAt])
}

model PushToken {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  user      User     @relation("UserPushTokens", fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique
  platform  String   // "ios" or "android"
  createdAt DateTime @default(now()) @map("created_at")

  @@map("push_tokens")
  @@index([userId])
}

model LiveSession {
  id            String    @id @default(uuid())
  hostId        String    @map("host_id")
  host          User      @relation("UserLiveSessions", fields: [hostId], references: [id], onDelete: Cascade)
  title         String
  status        String    @default("waiting") // "waiting", "live", "ended"
  livekitRoom   String?   @map("livekit_room")
  aiAnalysisId  String?   @map("ai_analysis_id")
  aiAnalyzedAt  DateTime? @map("ai_analyzed_at")
  peakViewers   Int       @default(0) @map("peak_viewers")
  totalViewers  Int       @default(0) @map("total_viewers")
  startedAt     DateTime? @map("started_at")
  endedAt       DateTime? @map("ended_at")
  createdAt     DateTime  @default(now()) @map("created_at")

  chatMessages  LiveChatMessage[]
  viewers       LiveSessionViewer[]

  @@map("live_sessions")
  @@index([hostId, status])
  @@index([status, startedAt])
}

model LiveChatMessage {
  id          String      @id @default(uuid())
  sessionId   String      @map("session_id")
  session     LiveSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  userId      String?     @map("user_id")
  user        User?       @relation("UserLiveChatMessages", fields: [userId], references: [id], onDelete: SetNull)
  isAi        Boolean     @default(false) @map("is_ai")
  messageType String      @default("text") @map("message_type") // "text", "ai_feedback", "system"
  content     String      @db.Text
  createdAt   DateTime    @default(now()) @map("created_at")

  @@map("live_chat_messages")
  @@index([sessionId, createdAt])
}

model LiveSessionViewer {
  id        String      @id @default(uuid())
  sessionId String      @map("session_id")
  session   LiveSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  userId    String      @map("user_id")
  user      User        @relation("UserLiveSessionViews", fields: [userId], references: [id], onDelete: Cascade)
  joinedAt  DateTime    @default(now()) @map("joined_at")
  leftAt    DateTime?   @map("left_at")

  @@unique([sessionId, userId])
  @@map("live_session_viewers")
  @@index([sessionId])
  @@index([userId])
}

model StyleDNA {
  id             String   @id @default(uuid())
  outfitCheckId  String   @unique @map("outfit_check_id")
  outfitCheck    OutfitCheck @relation(fields: [outfitCheckId], references: [id], onDelete: Cascade)
  userId         String   @map("user_id")

  // Colors extracted from image
  dominantColors String[] @map("dominant_colors")   // ["navy", "white", "tan"]
  colorHarmony   String?  @map("color_harmony")     // "complementary", "analogous", "monochromatic", "neutral"
  colorCount     Int?     @map("color_count")

  // Style classification
  formalityLevel Int?     @map("formality_level")    // 1-5 (1=very casual, 5=black tie)
  styleArchetypes String[] @map("style_archetypes")  // ["minimalist", "classic", "streetwear"]
  silhouetteType String?  @map("silhouette_type")    // "fitted", "relaxed", "layered", "structured"

  // Garments detected
  garments       String[]                             // ["blazer", "chinos", "sneakers", "watch"]
  patterns       String[]                             // ["solid", "striped", "plaid"]
  textures       String[]                             // ["denim", "cotton", "leather", "knit"]

  // Scores (from AI analysis)
  colorScore       Float? @map("color_score")         // 1-10
  proportionScore  Float? @map("proportion_score")    // 1-10
  fitScore         Float? @map("fit_score")           // 1-10
  coherenceScore   Float? @map("coherence_score")     // 1-10

  createdAt DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([createdAt])
  @@map("style_dna")
}

model CalibrationSnapshot {
  id           String   @id @default(uuid())
  period       String   // "2026-02-W07", "2026-02"
  sampleSize   Int      @map("sample_size")
  avgAiScore   Float    @map("avg_ai_score")
  avgCommunity Float    @map("avg_community_score")
  delta        Float    // avgAiScore - avgCommunity (positive = AI scores higher)
  correlation  Float?   // Pearson correlation coefficient
  createdAt    DateTime @default(now()) @map("created_at")

  @@unique([period])
  @@map("calibration_snapshots")
}

model SubscriptionEvent {
  id             String   @id @default(uuid())
  userId         String   @map("user_id")
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  eventType      String   @map("event_type")
  productId      String?  @map("product_id")
  entitlementIds String[] @map("entitlement_ids")
  store          String?
  environment    String?

  rawPayload     Json?    @map("raw_payload")

  processedAt    DateTime @default(now()) @map("processed_at")

  @@map("subscription_events")
  @@index([userId, processedAt])
}

// ─── Recursive Self-Improvement ─────────────────────────────────────────────

model PromptVersion {
  id            String   @id @default(uuid())
  version       String   @unique // "v2.0", "v2.1-auto", "v2.1-auto-2", etc.
  parentVersion String?  @map("parent_version") // What version was this derived from
  promptText    String   @db.Text @map("prompt_text")
  source        String   // "manual", "auto-optimize", "a/b-winner"

  // Performance metrics (updated as data accumulates)
  sampleSize        Int    @default(0) @map("sample_size")
  avgAiScore        Float? @map("avg_ai_score")
  avgUserRating     Float? @map("avg_user_rating")
  avgCommunityDelta Float? @map("avg_community_delta") // |AI - community| lower is better
  helpfulPct        Float? @map("helpful_pct") // % marked helpful
  fallbackRate      Float? @map("fallback_rate") // % that hit fallback

  // A/B testing
  trafficPct    Float   @default(0) @map("traffic_pct") // 0-100, what % of requests use this
  isActive      Boolean @default(false) @map("is_active")
  isCandidate   Boolean @default(false) @map("is_candidate") // Challenger in A/B test
  promotedAt    DateTime? @map("promoted_at") // When this became the primary prompt

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("prompt_versions")
  @@index([isActive])
  @@index([createdAt])
}

model ImprovementCycle {
  id        String   @id @default(uuid())
  trigger   String   // "scheduled", "quality-drop", "manual"
  status    String   @default("running") // "running", "completed", "failed", "promoted"

  // What triggered it
  triggerMetrics Json? @map("trigger_metrics") // Snapshot of metrics that triggered the cycle

  // What was generated
  sourceVersion    String? @map("source_version") // Parent prompt version
  candidateVersion String? @map("candidate_version") // Generated prompt version

  // Results
  weaknessesFound   Json?   @map("weaknesses_found") // Top weaknesses identified
  knowledgeExtracted Json?  @map("knowledge_extracted") // New fashion rules discovered
  improvementDelta   Float? @map("improvement_delta") // Avg score improvement

  startedAt   DateTime  @default(now()) @map("started_at")
  completedAt DateTime? @map("completed_at")
  log         String?   @db.Text // Human-readable log

  @@map("improvement_cycles")
  @@index([status])
  @@index([startedAt])
}

model DiscoveredRule {
  id          String   @id @default(uuid())
  category    String   // "color", "proportion", "occasion", "seasonal", "archetype"
  rule        String   @db.Text // The discovered fashion rule
  confidence  Float    // 0-1, how statistically significant
  sampleSize  Int      @map("sample_size")
  evidence    String?  @db.Text // Supporting data summary

  // Whether it's been incorporated into the prompt
  incorporated    Boolean  @default(false)
  incorporatedIn  String?  @map("incorporated_in") // Prompt version that includes this rule

  discoveredAt DateTime @default(now()) @map("discovered_at")

  @@map("discovered_rules")
  @@index([category])
  @@index([incorporated])
}
